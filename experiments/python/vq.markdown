### 1. Исходные данные

* X(N, D) --- матрица исходных данных.
* Q - случайно выбранная строка размера [D] из Х или отдельо сгенерырованные данные. 

### 2.  Обучение

На данный момент процес обучения не был рассмотрен. Тем не менее стоит отметить несколько перменных учавствующих в кодировке векторов.

*  `OPQEncoder.centroids`  ---  3-х мерный массив размера [C1,C2,D/C2]. Содержит точные значения, соответсвующие кодированным. Получены в результате обучения. Значения С1, С2 задаются\вычисляются в функции `OPQEncoder._parse_codebook_params`. Эти переменные имеет следующее знгачение:
	* С1 - количество значений для участка при разделении
	* С2 - количество участков, на которые делится строка Х
	* D/C2 - размер каждого участка

* `OPQEncoder.offsets` --- $ (2^i , i = 0,1,...,C2-1) $

* `OPQEncoder.rotations` --- массив матриц, перемножаемых с  частями Х поочередно. Используется в случае алгоритма "bolt"

* `OPQEncoder.R` --- одиночная матрица, аналогичная `OPQEncoder.rotations`. Применяется в алгоритме "opq"

На основании названий методов и значений переменных можно предположить что `OPQEncoder.rotations` и `OPQEncoder.R` --- линейные преобразования.

* `OPQEncoder.lut_offsets` - массив смещений размера [D], получен в результате обучения.

* `OPQEncoder.scale_by` - маштаб, получен в результате обучения.

### 3. Encode X

Рассматривается метод `OPQEncoder.encode_X`

1.  Выполняются "повороты" вектора Х в зависимости от алгоритма. В обоих случаях используется умножение матриц.
``` python
if self.algo == 'OPQ':
	X = pq.opq_rotate(X, self.R)
elif self.algo == 'Bolt':
	X = pq.bopq_rotate(X, self.rotations)
```
2. Далее действия происходят с каждой строкой Х
    1. Она формирует матрицу [C2, D/C2]
    2. Вычисляется покомпонентное расстояние до каждой строки `OPQEncoder.centroids`. Расстояние вычисляется по одной из следующих формул(c - строка `OPQEncoder.centroids`, х - строка Х) : 
    $$  (c - x)^2 $$
    $$  |c - x| $$
    В результатеполучает массив расстояний `dist`[C1,C2,D/C2]
    3. Складываем значения `dist` вдоль последней оси. Т.е. получаем матрицу расстояний между контрольными значениями и исходными данными.
    4. Выбираем минимальные значения в каждом столбце. Их индексы и будут закодированным значением строки
    5. Для того, чтобы различать элементы строки после преобразований формы массивы,  к каждому элементу прибавляется соответсвующий элемент `OPQEncoder.offsets`
``` python
# Пункты 2.3 , 2.4
dists = np.sum(dists, axis=2)
idxs[i, :] = np.argmin(dists, axis=0)
```
### 4. Encode Q

Рассматривается метод `OPQEncoder.fit_query`

1. Выполняеются действия аналогичные пункту 1 Encode X

2.  Действия аналогичные пунтктам 2.2, 2.3 Encode X. Результат заносится в переменную `lut`

3.  Смещение, маштабирование, округление к целому. 
``` python
lut = np.maximum(0, lut - self.lut_offsets)
lut = np.floor(lut * self.scale_by).astype(np.int)
```
4. Элементы матрицы, превышающие 255, заменяются на 255
5. Результат записывается в переменную `OPQEncoder.q_disits_`
